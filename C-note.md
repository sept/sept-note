#C-progrm note

##指针
只有它能存储数据地址

所有定义 int * 就是指针变量

定义之后才能把地址赋给它

通过 * 取出该地址内的内容

    int b;
    int a;
    int *ptr;  "定义指针ptr"
    ptr = &a;  "取a 的地址给ptr"

    b = a;	  
    即 b = *ptr

指针大小一般和整型大小一样
        sizeof()     
###注意：
    指针 是存地址 变量

    指针指向那个变量或空间其实是  变量或空间的地址赋给指针

字符串后面加“ \0 ”即为字符串数组（一般都比有效长度至少大1）

###while（）语句先判断再循环

###do while 反之

##调用/使用  库函数

        strcpy
        #include <string.h>

编辑-------》编译--------》链接
      gcc     |             |
              |             |
             二进制      可执行


##状态机编程思想
1、笔试题

    请写出c语言编程中main 函数的原型

2、 请举例说明以上参数的含义。

	main只有这两个参数。
    
    argc表示参数（包括程序名）个数，argv是一个指针数组，其中每个指针指向一个字符串，即一个参数，
    
    因此argv[0]就是程序名，argv[1]就是第一个参数

    比如 #./sort 1 2
	
    则argc=3，argv[0]是"sort",argv[1]是"1"，argv[2]是"2"。

3、请你模仿shell的处理，把一个字符串按空格作为字符间隔符，转化为argc和argv[]的形式

       char str[128];
       int argc;
       char * argv[16];

       void parse(void)
       {
        ???
       }
4、状态机编程思想是一种编程模型
    
    难点在于画出设计好状态和确定状态迁移图
	
    适用于对于字符流进行处理和输出的题目
	
    最终的程序可以很简洁（demo）

5、课后实践：C语言取注释问题
##算法

##函数的递归调用

  栈空间

##二维数组

        int a[2][3];                               或   int a[2][3]
        int *p;                                          int *p[N];
        p = a[0];      而不能写成p = a;                  p = a;

##结构体
      eg :
      struct data           //定义 结构体 为data（可包括多种类型），和 基本类型用法 是一样的
      { 
        int a;
        char c;
      }
这时在内存中是不会出现任何的空间跟它有关系 

只有当data 后加一个变量，比如是‘M’ 时  才会在内存中出现空间（struct data）

操作时 m.a  即整型      m.c    字符串型

###typedef
它用来对一个资料类型起一个新名字。目的是为了使源代码更易于阅读和理解。

它是语言编译过程的一部分，但它并不实际分配内存空间

      比如：typedef struc data STU （新的变量） 
                           
                   (原来变量)
                           
             即为 STU m;
对于结构体开辟的空间的大小 用关键字 sizeof () 括号里是变量或 类型
 
            eg : sizeof (int/a)/(STU/m)
 
对于结构体在它内部不可以调用或包含它本身（因为开辟结构体的空间是一定的 如果在里面再调用或包含它本身 则会使空间不足难以使用） 

， 可以包含指向自己的指针

## union 和 struct

###共用体

构造数据类型,也叫联合体

用途：使几个不同类型的变量共占一段内存(相互覆盖)

###结构体是一种构造数据类型

用途：把不同类型的数据组合成一个整体-------自定义数据类型

---------------------------------------------------------------

结构体变量所占内存长度是各成员占的内存长度的总和。

共同体变量所占内存长度是各最长的成员占的内存长度。

共同体每次只能存放哪个的一种！！

共同体变量中起作用的成员是尊后一次存放的成员，

在存入新的成员后原有的成员失去了作用！

---------------------------------------------------------------

Structure 与 Union主要有以下区别:

1. struct和union都是由多个不同的数据类型成员组成, 

但在任何同一时刻, union中只存放了一个被选中的成员, 而struct的所有成员都存在。

在struct中，各成员都占有自己的内存空间，它们是同时存在的。一个struct变量的总长度等于所有成员长度之和。

在Union中，所有成员不能同时占用它的内存空间，它们不能同时存在。Union变量的长度等于最长的成员的长度。

2. 对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于struct的不同成员赋值是互不影响的。

##文件

###__fopen__:

__函数简介__:

　　函数功能： 打开一个文件

　　函数原型：FILE * fopen(const char * path,const char * mode);

　　相关函数：open，fclose

　　所需库： <stdio.h>

　　返回值： 文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回NULL，并把错误代码存在errno 中。

　　一般而言，打开文件后会作一些文件读取或写入的动作，若打开文件失败，接下来的读写动作也无法顺利进行，所以一般在fopen()后作错误判断及处理。

__参数说明__：

　　参数path字符串包含欲打开的文件路径及文件名，参数mode字符串则代表着流形态。

　　mode有下列几种形态字符串:

　　r 以只读方式打开文件，该文件必须存在。

　　r+ 以可读写方式打开文件，该文件必须存在。

　　rb+ 读写打开一个二进制文件，只允许读写数据。

　　rt+ 读写打开一个文本文件，允许读和写。

　　w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。

　　w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。

　　a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）

　　a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）

　　wb 只写打开或新建一个二进制文件；只允许写数据。

　　wb+ 读写打开或建立一个二进制文件，允许读和写。

　　wt+ 读写打开或着建立一个文本文件；允许读写。

　　at+ 读写打开一个文本文件，允许读或在文本末追加数据。

　　ab+ 读写打开一个二进制文件，允许读或在文件末追加数据。

##在C语言中提供了多种文件读写的函数:

###一、读字符函数fgetc   
   
fgetc函数的功能是从指定的文件中读一个字符，函数调用的形式为： 字符变量=fgetc(文件指针)； 

例如：ch=fgetc(fp);其意义是从打开的文件fp中读取一个字符并送入ch中。   
   
对于fgetc函数的使用有以下几点说明：   
   
1. 在fgetc函数调用中，读取的文件必须是以读或读写方式打开的。   
   
2. 读取字符的结果也可以不向字符变量赋值，例如：fgetc(fp);但是读出的字符不能保存。   
   
3. 在文件内部有一个位置指针。用来指向文件的当前读写字节。在文件打开时，该指针总是指向文件的第一个字节。

使用fgetc 函数后， 该位置指针将向后移动一个字节。 因此可连续多次使用fgetc函数，读取多个字符。 

应注意文件指针和文件内部的位置指针不是一回事。文件指针是指向整个文件的，须在程序中定义说明，只要不重新赋值，

文件指针的值是不变的。文件内部的位置指针用以指示文件内部的当前读写位置，每读写一次，该指针均向后移动，

它不需在程序中定义说明，而是由系统自动设置的。

### 二、写字符函数fputc   
   
fputc函数的功能是把一个字符写入指定的文件中，函数调用的 形式为： fputc(字符量，文件指针)； 

其中，待写入的字符量可以是字符常量或变量，例如：fputc('a',fp);其意义是把字符a写入fp所指向的文件中。   
   
 对于fputc函数的使用也要说明几点：   
   
 1. 被写入的文件可以用、写、读写，追加方式打开，用写或读写方式打开一个已存在的文件时将清除原有的文件内容，
 
 写入字符从文件首开始。如需保留原有文件内容，希望写入的字符以文件末开始存放，必须以追加方式打开文件。
 
 被写入的文件若不存在，则创建该文件。   
   
 2. 每写入一个字符，文件内部位置指针向后移动一个字节。   
   
 3. fputc函数有一个返回值，如写入成功则返回写入的字符， 否则返回一个EOF。可用此来判断写入是否成功。   
   
###函数名: rewind

功  能: 将文件指针重新指向一个流的开头

用  法: int rewind(FILE *stream);

###EOF  

文件结束符 即end of file

###fseek函数:

用法： int fseek(FILE *stream, long offset, int whence);

功能： 把fp的文件读写位置指针移到指定的位置

###fread and fwrite
        fread, fwrite - binary stream input/output

        size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
        size_t fwrite(const void *ptr, size_t size, size_t nmemb,

###getchar()  和 getch()

getchar 由宏实现：#define getchar() getc(stdin)。

getchar有一个int型的返回值.当程序调用getchar时.程序就等着用户按键.用户输入的字符被存放在键盘缓冲区中.

__直到用户按回车为止(回车字符也放在缓冲区中)__.

当用户键入回车之后,getchar才开始从stdin流中每次读入一个字符.

getchar函数的返回值是用户输入的第一个字符的ASCII码,如出错返回-1,且将用户输入的字符回显到屏幕.

如用户在按回车之前输入了不止一个字符,其他字符会保留在键盘缓存区中,等待后续 getchar调用读取.

也就是说,后续的getchar调用不会等待用户按键,而直接读取缓冲区中的字符,直到缓冲区中的字符读完为后,才等待用户按键.
　　
getch与getchar基本功能相同,差别是getch直接从键盘获取键值,不等待用户按回车,只要用户按一个键,getch就立刻返回, 

getch返回值是用户输入的ASCII码,出错返回-1.输入的字符不会回显在屏幕上.

getch函数常用于程序调试中,在调试时,在关键位置显示有关的结果以待查看,然后用getch函数暂停程序运行,当按任意键后程序继续运行.

这个版本忽略了个重点，getch()是非缓冲输入函数，就是不能用getch（）来接受缓冲区已存在的字符，
