#C-progrm note

##指针
只有它能存储数据地址

所有定义 int * 就是指针变量

定义之后才能把地址赋给它

通过 * 取出该地址内的内容

    int b;
    int a;
    int *ptr;  "定义指针ptr"
    ptr = &a;  "取a 的地址给ptr"

    b = a;	  
    即 b = *ptr

指针大小一般和整型大小一样
        sizeof()     
###注意：
    指针 是存地址 变量

    指针指向那个变量或空间其实是  变量或空间的地址赋给指针

字符串后面加“ \0 ”即为字符串数组（一般都比有效长度至少大1）

###while（）语句先判断再循环

###do while 反之

##调用/使用  库函数

        strcpy
        #include <string.h>

编辑-------》编译--------》链接
      gcc     |             |
              |             |
             二进制      可执行


##状态机编程思想
1、笔试题

    请写出c语言编程中main 函数的原型

2、 请举例说明以上参数的含义。

	main只有这两个参数。
    
    argc表示参数（包括程序名）个数，argv是一个指针数组，其中每个指针指向一个字符串，即一个参数，
    
    因此argv[0]就是程序名，argv[1]就是第一个参数

    比如 #./sort 1 2
	
    则argc=3，argv[0]是"sort",argv[1]是"1"，argv[2]是"2"。

3、请你模仿shell的处理，把一个字符串按空格作为字符间隔符，转化为argc和argv[]的形式

       char str[128];
       int argc;
       char * argv[16];

       void parse(void)
       {
        ???
       }
4、状态机编程思想是一种编程模型
    
    难点在于画出设计好状态和确定状态迁移图
	
    适用于对于字符流进行处理和输出的题目
	
    最终的程序可以很简洁（demo）

5、课后实践：C语言取注释问题
##算法

##函数的递归调用

  栈空间

##二维数组

        int a[2][3];                               或   int a[2][3]
        int *p;                                          int *p[N];
        p = a[0];      而不能写成p = a;                  p = a;

##结构体
      eg :
      struct data           //定义 结构体 为data（可包括多种类型），和 基本类型用法 是一样的
      { 
        int a;
        char c;
      }
这时在内存中是不会出现任何的空间跟它有关系 

只有当data 后加一个变量，比如是‘M’ 时  才会在内存中出现空间（struct data）

操作时 m.a  即整型      m.c    字符串型

###typedef
它用来对一个资料类型起一个新名字。目的是为了使源代码更易于阅读和理解。

它是语言编译过程的一部分，但它并不实际分配内存空间

      比如：typedef struc data STU （新的变量） 
                           
                   (原来变量)
                           
             即为 STU m;
对于结构体开辟的空间的大小 用关键字 sizeof () 括号里是变量或 类型
 
            eg : sizeof (int/a)/(STU/m)
 
对于结构体在它内部不可以调用或包含它本身（因为开辟结构体的空间是一定的 如果在里面再调用或包含它本身 则会使空间不足难以使用） 

， 可以包含指向自己的指针

## union 和 struct

###共用体

构造数据类型,也叫联合体

用途：使几个不同类型的变量共占一段内存(相互覆盖)

###结构体是一种构造数据类型

用途：把不同类型的数据组合成一个整体-------自定义数据类型

---------------------------------------------------------------

结构体变量所占内存长度是各成员占的内存长度的总和。

共同体变量所占内存长度是各最长的成员占的内存长度。

共同体每次只能存放哪个的一种！！

共同体变量中起作用的成员是尊后一次存放的成员，

在存入新的成员后原有的成员失去了作用！

---------------------------------------------------------------

Structure 与 Union主要有以下区别:

1. struct和union都是由多个不同的数据类型成员组成, 

但在任何同一时刻, union中只存放了一个被选中的成员, 而struct的所有成员都存在。

在struct中，各成员都占有自己的内存空间，它们是同时存在的。一个struct变量的总长度等于所有成员长度之和。

在Union中，所有成员不能同时占用它的内存空间，它们不能同时存在。Union变量的长度等于最长的成员的长度。

2. 对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于struct的不同成员赋值是互不影响的。

##文件

###__fopen__:

__函数简介__:

　　函数功能： 打开一个文件

　　函数原型：FILE * fopen(const char * path,const char * mode);

　　相关函数：open，fclose

　　所需库： <stdio.h>

　　返回值： 文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回NULL，并把错误代码存在errno 中。

　　一般而言，打开文件后会作一些文件读取或写入的动作，若打开文件失败，接下来的读写动作也无法顺利进行，所以一般在fopen()后作错误判断及处理。

__参数说明__：

　　参数path字符串包含欲打开的文件路径及文件名，参数mode字符串则代表着流形态。

　　mode有下列几种形态字符串:

　　r 以只读方式打开文件，该文件必须存在。

　　r+ 以可读写方式打开文件，该文件必须存在。

　　rb+ 读写打开一个二进制文件，只允许读写数据。

　　rt+ 读写打开一个文本文件，允许读和写。

　　w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。

　　w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。

　　a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）

　　a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）

　　wb 只写打开或新建一个二进制文件；只允许写数据。

　　wb+ 读写打开或建立一个二进制文件，允许读和写。

　　wt+ 读写打开或着建立一个文本文件；允许读写。

　　at+ 读写打开一个文本文件，允许读或在文本末追加数据。

　　ab+ 读写打开一个二进制文件，允许读或在文件末追加数据。
